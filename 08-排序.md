
# 分类

按排序方法分类

![](Pasted%20image%2020240929123256.png)


按存储介质分

![](Pasted%20image%2020240929123856.png)

按比较器个数可分为

![](Pasted%20image%2020240929124124.png)

按主要操作可分为

![](Pasted%20image%2020240929133803.png)

按辅助空间

![](Pasted%20image%2020240929135523.png)

按稳定性

![](Pasted%20image%2020240929135554.png)

![](Pasted%20image%2020240929135748.png)

![](Pasted%20image%2020240929135918.png)

![](Pasted%20image%2020240929140139.png)



![](Pasted%20image%2020240929141548.png)



# 插入排序

![](Pasted%20image%2020240929145309.png)

## 直接插入排序

使用顺序查找法查找插入位置

![](Pasted%20image%2020240929161401.png)

使用哨兵

![](Pasted%20image%2020240929161849.png)

## 折半插入排序

![](Pasted%20image%2020240929163556.png)

## 希尔排序


![](Pasted%20image%2020240929184039.png)


![](Pasted%20image%2020240929184442.png)

*过程*

排序对不相邻的记录进行比较和移动：

1. 将待排序序列分为若干子序列（每个子序列的元素在原始数组中间距相同）；
2. 对这些子序列进行插入排序；
3. 减小每个子序列中元素之间的间距，重复上述过程直至间距减少为 ![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "1")。

```c
class Solution {
    public int[] sortArray(int[] nums){
    shellSort(nums);
    return nums;
  }

  public void shellSort(int[] nums){
        for(int step = nums.length >> 1; step >= 1; step = step >> 1){
            for(int start = step; start < nums.length; start++){
                for(int j = start - step; j >= 0 && nums[j + step] < nums[j]; j-=step){
                    swap(nums, j, j + step);
                }
            }
        }
    }

    public void swap(int[] arr, int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

# 交换排序

![](Pasted%20image%2020240929194758.png)

## 快速排序

——改进的交换排序

